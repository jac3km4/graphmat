use bumpalo::collections::Vec as BumpVec;
use bumpalo::Bump;

use crate::graph::Star;
use crate::heuristics::EdgeDistanceHeuristic;
use crate::levenshtein::{levenshtein, Edit};
use crate::object::CodeMetadata;

const INSERT_DELETE_COST: usize = 1;
const CONFLICT_COST: usize = 1;

pub fn match_star(
    lhs: Star<'_, u64>,
    rhs: Star<'_, u64>,
    heuristics: &impl EdgeDistanceHeuristic,
    ctx: MatchContext<'_>,
    bump: &Bump,
) -> (usize, Vec<(u64, u64)>) {
    // The initial cost is based on the distance between the two sets of opcodes.
    let mut cost = levenshtein(
        ctx.lhs_metadata.get_function(*lhs.vertex()).unwrap().opcodes(),
        ctx.rhs_metadata.get_function(*rhs.vertex()).unwrap().opcodes(),
        bump,
    );

    let mat = heuristics.label(lhs.edges().copied(), rhs.edges().copied(), ctx, bump);

    // The mapping between edges is generated by iterating through an edit sequence obtained
    // from a Levenshtein matrix. Substitutions and noops correspond to simple mappings between
    // two edges, while deletions and insertions generate no mappings, but increase the cost.
    let mut mappings = BumpVec::new_in(bump);
    for (i, edit) in mat.edits().with_indices() {
        let j = match edit {
            Edit::Substitute(j) => j,
            Edit::Noop if rhs.edges().len() > i => i,
            _ => {
                cost += INSERT_DELETE_COST;
                continue;
            }
        };
        mappings.push((*lhs.edges().nth(i).unwrap(), *rhs.edges().nth(j).unwrap()));
    }

    // Only the most frequent mapping for each left-hand side edge is kept.
    mappings.sort_unstable();
    let max_mappings = find_max_within_runs(&mappings, bump);
    // The cost is increased by the number of conflicting mappings.
    cost += count_conflicts(&mappings, &max_mappings) * CONFLICT_COST;

    (cost, max_mappings.to_vec())
}

/// Finds the most frequent mapping for each left-hand side index.
fn find_max_within_runs<'bump>(slice: &[(u64, u64)], bump: &'bump Bump) -> BumpVec<'bump, (u64, u64)> {
    let mut it = slice.iter().peekable();
    let mut results = BumpVec::new_in(bump);

    while let Some(&(l0, r0)) = it.next() {
        let mut count = 0;
        let mut max = 0;
        let mut current = r0;
        let mut candidate = r0;

        while let Some(&(l1, r1)) = it.peek() {
            if l0 == *l1 && current == *r1 {
                count += 1;
                it.next();
            } else if l0 == *l1 {
                if count > max {
                    max = count;
                    candidate = current;
                }
                count = 0;
                current = *r1;
                it.next();
            } else {
                break;
            }
        }
        results.push((l0, candidate));
    }
    results
}

/// Counts the number of conflicting mappings.
fn count_conflicts(original: &[(u64, u64)], dedup: &[(u64, u64)]) -> usize {
    let mut count = 0;
    let mut it = original.iter().peekable();

    for (l0, r0) in dedup {
        while let Some((_, r1)) = it.next_if(|(l1, _)| l0 == l1) {
            if r0 != r1 {
                count += 1;
            }
        }
    }
    count
}

/// Context used for matching stars in call graphs.
#[derive(Debug, Clone, Copy)]
pub struct MatchContext<'a> {
    lhs_metadata: &'a CodeMetadata,
    rhs_metadata: &'a CodeMetadata,
}

impl<'a> MatchContext<'a> {
    pub(crate) fn new(lhs_object: &'a CodeMetadata, rhs_object: &'a CodeMetadata) -> Self {
        Self {
            lhs_metadata: lhs_object,
            rhs_metadata: rhs_object,
        }
    }

    #[inline]
    pub(crate) fn lhs_metadata(&self) -> &'a CodeMetadata {
        self.lhs_metadata
    }

    #[inline]
    pub(crate) fn rhs_metadata(&self) -> &'a CodeMetadata {
        self.rhs_metadata
    }
}

#[cfg(test)]
mod test {
    use bumpalo::Bump;

    use super::*;

    #[test]
    fn test_find_max_runs() {
        let bump = Bump::new();
        let slice = &[
            (1, 3),
            (1, 3),
            (1, 4),
            (2, 5),
            (2, 6),
            (2, 6),
            (2, 6),
            (2, 7),
            (2, 7),
            (2, 8),
        ];
        let result = find_max_within_runs(slice, &bump);
        assert_eq!(result, &[(1, 3), (2, 6)]);
    }

    #[test]
    fn test_count_conflicts() {
        let original = &[
            (1, 3),
            (1, 3),
            (1, 4),
            (2, 5),
            (2, 6),
            (2, 6),
            (2, 6),
            (2, 7),
            (2, 7),
            (2, 8),
        ];
        let dedup = &[(1, 3), (2, 6)];
        let result = count_conflicts(original, dedup);
        assert_eq!(result, 5);
    }
}
